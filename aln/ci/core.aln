module ci.core {
    import std.fs;
    import std.proc;
    import std.log;
    import std.env;
    import tools.did_proxy;
    import tools.policy_check;
    import tools.audit_ci;

    contract Step {
        fn name() -> string;
        fn run() -> int;
    }

    struct CmdStep {
        label: string;
        cmd: string;
    }

    impl Step for CmdStep {
        fn name() -> string {
            return self.label;
        }

        fn run() -> int {
            log.info("ci", "running step: " + self.label);
            let code = proc.exec(self.cmd);
            if code != 0 {
                log.error("ci", "step failed: " + self.label + " exit=" + code.to_string());
            }
            return code;
        }
    }

    fn step_checkout() -> Step {
        return CmdStep {
            label: "checkout",
            cmd: "git fetch --tags --prune --unshallow || true",
        };
    }

    fn step_deps() -> Step {
        return CmdStep {
            label: "dependencies",
            cmd: "aln deps sync",
        };
    }

    fn step_lint() -> Step {
        return CmdStep {
            label: "lint",
            cmd: "aln lint",
        };
    }

    fn step_test() -> Step {
        return CmdStep {
            label: "test",
            cmd: "aln test --report junit:reports/aln-tests.xml",
        };
    }

    fn step_build() -> Step {
        return CmdStep {
            label: "build",
            cmd: "aln build --target ci",
        };
    }

    fn prepare_ci_session() -> int {
        let branch = env.get("GITHUB_REF_NAME");
        if (branch == "") { branch = "local"; }
        // Validate policy before requesting capabilities
        let pol_rc = tools.policy_check::main();
        if (pol_rc != 0) {
            log.error("ci", "policy_check failed; aborting pipeline");
            return 1;
        }
        let cap = did_proxy.request_ci_capability("aln-ci-core", branch);
        if (cap.value == "") {
            log.error("ci", "failed to obtain DID-based CI capability; aborting");
            return 1;
        }
        // Add redacted audit entry for this capability exchange
        let repo = env.get("GITHUB_REPOSITORY");
        audit_ci.log_event(repo, branch, "aln-ci-core", cap.scope);
        // Optionally set environment variable for downstream steps (not logged)
        // In real workflows we may use secrets or a secure context to pass the temporary capability safely
        return 0;
    }

    fn run_pipeline() -> int {
        let rc = prepare_ci_session();
        if (rc != 0) { return rc; }
        let steps: Step[] = [
            step_checkout(),
            step_deps(),
            step_lint(),
            step_test(),
            step_build(),
        ];

        for s in steps {
            let code = s.run();
            if code != 0 {
                log.error("ci", "pipeline failed on: " + s.name());
                return code;
            }
        }

        log.info("ci", "pipeline succeeded");
        return 0;
    }

    export fn main() -> int {
        return run_pipeline();
    }
}